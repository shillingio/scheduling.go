// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// SchedulerAvailabilitySearchRequest Providers Appointment Search
//
// Providers appointment search request for matching patients with the availability of relevant providers.
// Example: {"duration":15,"range_from":"2022-10-12T07:20:00Z","range_to":"2022-10-14T17:30:00Z","services":["eef8dc3f-e0c9-4ee8-ac96-81c63df9c98b","48247455-f5d8-43cf-97ea-c6c1bca4b071"],"zip":"92101"}
//
// swagger:model schedulerAvailabilitySearchRequest
type SchedulerAvailabilitySearchRequest struct {

	// The duration of the appointment in minutes
	// Required: true
	Duration *int32 `json:"duration"`

	// The ID of a specific providers to exclude those providers from search
	// results
	Exclude []string `json:"exclude"`

	// exclude by ref
	ExcludeByRef bool `json:"exclude_by_ref,omitempty"`

	// Appointment Format (ex: video, telephone, etc.)
	Format string `json:"format,omitempty"`

	// Return only in-person providers (default: false)
	InPerson bool `json:"in_person,omitempty"`

	// The IDs of specific providers to retrieve appointments for just those
	// providers
	Include []string `json:"include"`

	// include by ref
	IncludeByRef bool `json:"include_by_ref,omitempty"`

	// language
	Language string `json:"language,omitempty"`

	// Limit the number of results to return. (default: 10)
	Limit int32 `json:"limit,omitempty"`

	// Location filter for proximity search for in_person appointments
	Location *SchedulingLocation `json:"location,omitempty"`

	// Offset the results count if pagination is necessary based on the limit and
	// total fields in the response
	Offset int32 `json:"offset,omitempty"`

	// The start of the requested date/time range in RFC3339 format
	// Required: true
	RangeFrom *string `json:"range_from"`

	// The end of the requested date/time range in RFC3339 format
	// Required: true
	RangeTo *string `json:"range_to"`

	// The service UUID requested by the patient
	// Required: true
	ServiceID *string `json:"service_id"`

	// State the provider is licensed in for the requested service
	State string `json:"state,omitempty"`

	// timezone code
	TimezoneCode int32 `json:"timezone_code,omitempty"`

	// timezone name
	TimezoneName int32 `json:"timezone_name,omitempty"`

	// timezone offset
	TimezoneOffset int32 `json:"timezone_offset,omitempty"`

	// ZIP code the patient resides in
	// Required: true
	Zip *string `json:"zip"`
}

// Validate validates this scheduler availability search request
func (m *SchedulerAvailabilitySearchRequest) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDuration(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLocation(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRangeFrom(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRangeTo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateServiceID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateZip(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SchedulerAvailabilitySearchRequest) validateDuration(formats strfmt.Registry) error {

	if err := validate.Required("duration", "body", m.Duration); err != nil {
		return err
	}

	return nil
}

func (m *SchedulerAvailabilitySearchRequest) validateLocation(formats strfmt.Registry) error {
	if swag.IsZero(m.Location) { // not required
		return nil
	}

	if m.Location != nil {
		if err := m.Location.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("location")
			}
			return err
		}
	}

	return nil
}

func (m *SchedulerAvailabilitySearchRequest) validateRangeFrom(formats strfmt.Registry) error {

	if err := validate.Required("range_from", "body", m.RangeFrom); err != nil {
		return err
	}

	return nil
}

func (m *SchedulerAvailabilitySearchRequest) validateRangeTo(formats strfmt.Registry) error {

	if err := validate.Required("range_to", "body", m.RangeTo); err != nil {
		return err
	}

	return nil
}

func (m *SchedulerAvailabilitySearchRequest) validateServiceID(formats strfmt.Registry) error {

	if err := validate.Required("service_id", "body", m.ServiceID); err != nil {
		return err
	}

	return nil
}

func (m *SchedulerAvailabilitySearchRequest) validateZip(formats strfmt.Registry) error {

	if err := validate.Required("zip", "body", m.Zip); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this scheduler availability search request based on the context it is used
func (m *SchedulerAvailabilitySearchRequest) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLocation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SchedulerAvailabilitySearchRequest) contextValidateLocation(ctx context.Context, formats strfmt.Registry) error {

	if m.Location != nil {
		if err := m.Location.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("location")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("location")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SchedulerAvailabilitySearchRequest) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SchedulerAvailabilitySearchRequest) UnmarshalBinary(b []byte) error {
	var res SchedulerAvailabilitySearchRequest
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
